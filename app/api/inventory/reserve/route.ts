import { NextResponse } from 'next/server'
import { prisma } from '@/lib/db'

// POST /api/inventory/reserve - Reserve stock for an order (FIFO)
export async function POST(request: Request) {
  try {
    const body = await request.json()
    const { orderId, inventoryItemId, quantity } = body

    if (!orderId || !inventoryItemId || !quantity) {
      return NextResponse.json(
        { error: 'orderId, inventoryItemId, and quantity are required' },
        { status: 400 }
      )
    }

    // Get available lots (FIFO - oldest first)
    const lots = await prisma.inventoryLot.findMany({
      where: {
        inventoryItemId,
        quantity: { gt: 0 }
      },
      orderBy: { producedAt: 'asc' } // FIFO
    })

    // Calculate total available
    const totalAvailable = lots.reduce((sum, lot) => sum + lot.quantity, 0)

    if (totalAvailable < quantity) {
      return NextResponse.json({
        error: 'Insufficient stock',
        available: totalAvailable,
        requested: quantity
      }, { status: 400 })
    }

    // Reserve from lots (FIFO)
    let remaining = quantity
    const reservations = []

    for (const lot of lots) {
      if (remaining <= 0) break

      const toReserve = Math.min(lot.quantity, remaining)

      // Create reservation
      const reservation = await prisma.inventoryReservation.create({
        data: {
          orderId,
          inventoryItemId,
          inventoryLotId: lot.id,
          quantity: toReserve,
          status: 'RESERVED'
        }
      })

      // Decrease lot quantity
      await prisma.inventoryLot.update({
        where: { id: lot.id },
        data: { quantity: { decrement: toReserve } }
      })

      reservations.push(reservation)
      remaining -= toReserve
    }

    // Update current stock on inventory item
    const updatedItem = await prisma.inventoryItem.update({
      where: { id: inventoryItemId },
      data: { currentStock: { decrement: quantity } },
      select: { id: true, name: true, currentStock: true, minStock: true, maxStock: true, productType: true }
    })

    // Auto-replenishment: if stock drops below minStock, create a production task
    let replenishmentTask = null
    if (updatedItem.currentStock < updatedItem.minStock) {
      // Check if there's already a pending replenishment task
      const existingTask = await prisma.stockProductionTask.findFirst({
        where: {
          inventoryItemId,
          status: { in: ['PENDING', 'IN_PROGRESS'] },
          isAutoGenerated: true
        }
      })

      if (!existingTask) {
        // Calculate how much to produce to reach maxStock (or minStock + buffer if no max)
        const targetQty = updatedItem.maxStock
          ? updatedItem.maxStock - updatedItem.currentStock
          : updatedItem.minStock * 2 - updatedItem.currentStock

        if (targetQty > 0) {
          // Schedule for tomorrow
          const tomorrow = new Date()
          tomorrow.setDate(tomorrow.getDate() + 1)
          tomorrow.setHours(6, 0, 0, 0)

          replenishmentTask = await prisma.stockProductionTask.create({
            data: {
              inventoryItemId,
              taskType: updatedItem.productType === 'FROSTING' || updatedItem.productType === 'FILLING' ? 'PREP' : 'BAKE',
              taskName: `[AUTO] Replenish ${updatedItem.name}`,
              targetQuantity: targetQty,
              completedQuantity: 0,
              scheduledDate: tomorrow,
              status: 'PENDING',
              priority: 1, // High priority for auto-generated replenishment
              isAutoGenerated: true
            }
          })
        }
      }
    }

    return NextResponse.json({
      success: true,
      reserved: quantity,
      reservations,
      replenishmentTriggered: replenishmentTask !== null,
      replenishmentTask
    }, { status: 201 })
  } catch (error) {
    console.error('Failed to reserve stock:', error)
    return NextResponse.json(
      { error: 'Failed to reserve stock' },
      { status: 500 }
    )
  }
}

// DELETE /api/inventory/reserve - Cancel a reservation
export async function DELETE(request: Request) {
  try {
    const { searchParams } = new URL(request.url)
    const reservationId = searchParams.get('id')

    if (!reservationId) {
      return NextResponse.json(
        { error: 'Reservation ID is required' },
        { status: 400 }
      )
    }

    const reservation = await prisma.inventoryReservation.findUnique({
      where: { id: parseInt(reservationId) }
    })

    if (!reservation) {
      return NextResponse.json(
        { error: 'Reservation not found' },
        { status: 404 }
      )
    }

    if (reservation.status !== 'RESERVED') {
      return NextResponse.json(
        { error: 'Only RESERVED items can be cancelled' },
        { status: 400 }
      )
    }

    // Return stock to lot
    if (reservation.inventoryLotId) {
      await prisma.inventoryLot.update({
        where: { id: reservation.inventoryLotId },
        data: { quantity: { increment: reservation.quantity } }
      })
    }

    // Update current stock
    await prisma.inventoryItem.update({
      where: { id: reservation.inventoryItemId },
      data: { currentStock: { increment: reservation.quantity } }
    })

    // Update reservation status
    await prisma.inventoryReservation.update({
      where: { id: parseInt(reservationId) },
      data: { status: 'CANCELLED' }
    })

    return NextResponse.json({ success: true })
  } catch (error) {
    console.error('Failed to cancel reservation:', error)
    return NextResponse.json(
      { error: 'Failed to cancel reservation' },
      { status: 500 }
    )
  }
}

// PATCH /api/inventory/reserve - Mark reservation as used
export async function PATCH(request: Request) {
  try {
    const body = await request.json()
    const { reservationId } = body

    if (!reservationId) {
      return NextResponse.json(
        { error: 'reservationId is required' },
        { status: 400 }
      )
    }

    const reservation = await prisma.inventoryReservation.update({
      where: { id: reservationId },
      data: {
        status: 'USED',
        usedAt: new Date()
      }
    })

    return NextResponse.json(reservation)
  } catch (error) {
    console.error('Failed to mark reservation as used:', error)
    return NextResponse.json(
      { error: 'Failed to update reservation' },
      { status: 500 }
    )
  }
}

// GET /api/inventory/reserve - Get reservations for an order
export async function GET(request: Request) {
  const { searchParams } = new URL(request.url)
  const orderId = searchParams.get('orderId')

  if (!orderId) {
    return NextResponse.json(
      { error: 'orderId is required' },
      { status: 400 }
    )
  }

  try {
    const reservations = await prisma.inventoryReservation.findMany({
      where: { orderId: parseInt(orderId) },
      include: {
        InventoryItem: {
          select: { id: true, sku: true, name: true, productType: true }
        },
        InventoryLot: {
          select: { id: true, lotNumber: true, producedAt: true, expiresAt: true }
        }
      }
    })

    return NextResponse.json(reservations)
  } catch (error) {
    console.error('Failed to fetch reservations:', error)
    return NextResponse.json(
      { error: 'Failed to fetch reservations' },
      { status: 500 }
    )
  }
}
