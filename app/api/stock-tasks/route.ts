import { NextResponse } from 'next/server'
import { prisma } from '@/lib/db'

// GET /api/stock-tasks - List stock production tasks
export async function GET(request: Request) {
  const { searchParams } = new URL(request.url)
  const status = searchParams.get('status')
  const assignedToId = searchParams.get('assignedToId')
  const startDate = searchParams.get('startDate')
  const endDate = searchParams.get('endDate')
  const inventoryItemId = searchParams.get('inventoryItemId')
  const groupByDate = searchParams.get('groupByDate') === 'true'

  try {
    const where: Record<string, unknown> = {}

    if (status) {
      where.status = status
    }

    if (assignedToId) {
      where.assignedToId = parseInt(assignedToId)
    }

    if (inventoryItemId) {
      where.inventoryItemId = parseInt(inventoryItemId)
    }

    if (startDate && endDate) {
      where.scheduledDate = {
        gte: new Date(startDate),
        lte: new Date(endDate)
      }
    } else if (startDate) {
      where.scheduledDate = { gte: new Date(startDate) }
    } else if (endDate) {
      where.scheduledDate = { lte: new Date(endDate) }
    }

    const tasks = await prisma.stockProductionTask.findMany({
      where,
      include: {
        InventoryItem: {
          select: {
            id: true,
            sku: true,
            name: true,
            productType: true,
            flavor: true,
            currentStock: true,
            minStock: true
          }
        },
        AssignedToStaff: {
          select: { id: true, name: true }
        }
      },
      orderBy: [
        { scheduledDate: 'asc' },
        { priority: 'desc' },
        { createdAt: 'asc' }
      ]
    })

    // Group by date if requested
    if (groupByDate) {
      const tasksByDate: Record<string, typeof tasks> = {}
      for (const task of tasks) {
        const dateKey = task.scheduledDate.toISOString().split('T')[0]
        if (!tasksByDate[dateKey]) {
          tasksByDate[dateKey] = []
        }
        tasksByDate[dateKey].push(task)
      }

      const groupedTasks = Object.entries(tasksByDate)
        .sort(([a], [b]) => a.localeCompare(b))
        .map(([date, dateTasks]) => ({
          date,
          tasks: dateTasks.map(t => ({
            id: t.id,
            inventoryItemId: t.inventoryItemId,
            inventoryItemName: t.InventoryItem.name,
            productType: t.InventoryItem.productType,
            flavor: t.InventoryItem.flavor,
            taskType: t.taskType,
            taskName: t.taskName,
            targetQuantity: t.targetQuantity,
            completedQuantity: t.completedQuantity,
            status: t.status,
            scheduledDate: t.scheduledDate.toISOString(),
            durationMinutes: t.durationMinutes,
            assignedTo: t.AssignedToStaff?.name || t.assignedTo,
            priority: t.priority,
            isAutoGenerated: t.isAutoGenerated
          }))
        }))

      return NextResponse.json({ tasks: groupedTasks })
    }

    return NextResponse.json(tasks)
  } catch (error) {
    console.error('Failed to fetch stock tasks:', error)
    return NextResponse.json(
      { error: 'Failed to fetch stock tasks' },
      { status: 500 }
    )
  }
}

// POST /api/stock-tasks - Create a stock production task
export async function POST(request: Request) {
  try {
    const body = await request.json()
    const {
      inventoryItemId,
      taskType,
      taskName,
      targetQuantity,
      scheduledDate,
      scheduledStart,
      scheduledEnd,
      durationMinutes,
      assignedToId,
      priority,
      notes,
      isAutoGenerated
    } = body

    if (!inventoryItemId || !taskType || !taskName || !targetQuantity || !scheduledDate) {
      return NextResponse.json(
        { error: 'inventoryItemId, taskType, taskName, targetQuantity, and scheduledDate are required' },
        { status: 400 }
      )
    }

    // Get staff name if assigned
    let assignedTo = null
    if (assignedToId) {
      const staff = await prisma.staff.findUnique({
        where: { id: assignedToId },
        select: { name: true }
      })
      assignedTo = staff?.name || null
    }

    const task = await prisma.stockProductionTask.create({
      data: {
        inventoryItemId,
        taskType,
        taskName,
        targetQuantity,
        completedQuantity: 0,
        scheduledDate: new Date(scheduledDate),
        scheduledStart: scheduledStart ? new Date(scheduledStart) : null,
        scheduledEnd: scheduledEnd ? new Date(scheduledEnd) : null,
        durationMinutes: durationMinutes || null,
        status: 'PENDING',
        assignedToId: assignedToId || null,
        assignedTo,
        priority: priority || 0,
        notes: notes || null,
        isAutoGenerated: isAutoGenerated || false
      },
      include: {
        InventoryItem: {
          select: { id: true, name: true, productType: true }
        },
        AssignedToStaff: {
          select: { id: true, name: true }
        }
      }
    })

    return NextResponse.json(task, { status: 201 })
  } catch (error) {
    console.error('Failed to create stock task:', error)
    return NextResponse.json(
      { error: 'Failed to create stock task' },
      { status: 500 }
    )
  }
}
